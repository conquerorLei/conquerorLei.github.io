<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>conquerorLei</title>
  
  <subtitle>further study make me better</subtitle>
  <link href="https://conquerorlei.github.io/atom.xml" rel="self"/>
  
  <link href="https://conquerorlei.github.io/"/>
  <updated>2022-03-19T14:17:08.961Z</updated>
  <id>https://conquerorlei.github.io/</id>
  
  <author>
    <name>conquerorLei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL:过滤空值</title>
    <link href="https://conquerorlei.github.io/posts/e05b1b3/"/>
    <id>https://conquerorlei.github.io/posts/e05b1b3/</id>
    <published>2022-03-19T13:47:07.000Z</published>
    <updated>2022-03-19T14:17:08.961Z</updated>
    
    <content type="html"><![CDATA[<p>现在我有一张库存表，查询到的数据里面有某些字段是空的，如下图所示</p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/20220319215650.png" alt="包含null字段的表单">现在需要做的就是过滤数据库中no和product_date字段为空的数据</p><h2 id="过滤字段为null的方法"><a class="header-anchor" href="#过滤字段为null的方法">¶</a>过滤字段为null的方法</h2><p>过滤空字段，如果按照我的第一想法</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> batch<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">no</span> <span class="hljs-operator">!=</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">AND</span> product_date <span class="hljs-operator">!=</span> <span class="hljs-keyword">null</span>; <br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/20220319220137.png" alt="查询结果"></p><p>但是显然这是不行的，这是一个不好的编程方式，因为我们所熟知的，<code>null</code>在MySQl中是一个关键字，所以我们尽量不会选择这种来进行比较。</p><p>以下为几个过滤空值的方法</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">/* 不使用关键字的写法 */</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> batch<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">no</span> <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">AND</span> product_date <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;&#x27;</span>; <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> batch<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">no</span> <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">AND</span> product_date <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-comment">/* 使用关键字的写法 */</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> batch<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">AND</span> product_date <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></div></td></tr></table></figure><p>但是上述两种写法，第一种也就是不使用关键字的写法时很糟糕的，因为我的<code>product_date</code>字段使用的datatime数据类型，默认为NULL，但是又不能直接使用’NULL’判断。</p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/20220319221347.png" alt="第一种写法的错误"></p><p>那么最好的方式就是使用第二种写法，也就是使用is not null，这是对对象最直接的判断，对所有的数据类型都适用</p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/20220319221552.png" alt="正确过滤后的结果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在我有一张库存表，查询到的数据里面有某些字段是空的，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/QingShanxl/pictures/raw/master/img/20220319215650.png&quot; alt=&quot;包含null字段的</summary>
      
    
    
    
    <category term="Database" scheme="https://conquerorlei.github.io/categories/Database/"/>
    
    <category term="MySQL" scheme="https://conquerorlei.github.io/categories/Database/MySQL/"/>
    
    
    <category term="SQL" scheme="https://conquerorlei.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式+策略模式实现消除if-else</title>
    <link href="https://conquerorlei.github.io/posts/44788a85/"/>
    <id>https://conquerorlei.github.io/posts/44788a85/</id>
    <published>2022-02-23T10:40:31.000Z</published>
    <updated>2022-02-24T13:02:17.038Z</updated>
    
    <content type="html"><![CDATA[<p>现实编程过程中会出现很多if-else叠加的场景，比如最近在编写一个Spring Boot项目，在服务层抛出了很多异常，在控制层对服务层抛出的异常进行了处理，而对于Spring Boot项目而言，能够使用ExceptionHandler注解直接捕获所有抛出的异常，但是在进行异常处理的时候，需要向前端返回状态码，每一个异常都对应了一个状态码。具体原因是为了让注解看着不那么臃肿，所以对异常进行了分类组合进行继承，只需要捕获基类就好；其次，我们并不知道捕获的异常实际上是哪个异常，这就牵扯到了对捕获的异常进行instanceof判断，随着业务代码的逐渐深入，if-else就会越来越多，长此以往对于代码的可读性有一定的影响。本文从设计模式的角度对上述业务场景进行了优化，使用策略模式和工厂模式对代码进行了重构。</p><h2 id="策略模式"><a class="header-anchor" href="#策略模式">¶</a>策略模式</h2><h3 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h3><p>策略模式中定义了一组同类型的算法，用不同的类进行封装，可以根据实际业务场景进行切换，以下为其书籍说明</p><blockquote><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p></blockquote><p>举个例子说明一下，我们在购买商品的时候会出现很多选择问题，在很多商场对于不同商品会有不同折扣，这个时候我们常见的操作就是if-else进行判断，但是一旦参与折扣的商品变得多的，后期对于一些折扣的修改与删除，再去翻原来的if-else列表，有点不太方便，这样将一个个折扣看成一个一个策略，在结账时根据用户购买的商品进行折扣策略的智能选择。能够对代码进行优化使其更具有可读性。</p><blockquote><p>可能会有人杠哈，就是一个全局搜索嘛，看不起谁呢？其实本身能够使用if-else进行实现也是可以的，但是在学习阶段，我们还是要以能写出高质量代码来约束自己；并且实际业务场景也不一定像文中提到的那么简单，所以时候就显示出来策略模式的优越性了。如果在if-else中写了大量的代码，后期对代码的修改和维护也很不方便。</p></blockquote><p>以下从代码角度进行一个解释</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Option option = 商品选择<br><span class="hljs-keyword">if</span>(option == 鞋子)&#123;<br>    鞋子打折算法;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(option == 衣服)&#123;<br>    衣服打折算法;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(option == ...)&#123;<br>    ...打折算法;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述的代码主要违反了OOP的两个原则，分别为：</p><ul><li><p>单一职责原则：一个类只有一个修改的原因，但是上述代码后端逻辑一旦变化，那么当前方法也将被改变</p></li><li><p>开闭原则：对扩展开放，对修改关闭。一旦后期需要对商品的折扣信息进行修改增加或者删除，那么都会违反开闭原则</p></li></ul><p>在阿里提供的《Java开发手册》中，这样写道</p><blockquote><p>超过3层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现</p></blockquote><h3 id="结合项目进行分析"><a class="header-anchor" href="#结合项目进行分析">¶</a>结合项目进行分析</h3><p>本项目中由于出现了很多的异常，不同的异常要返回不同的状态码，所以最开始就是很多的if-else叠加，随着业务的开发，if-else甚至超过了8个，以下为起始版本</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler(&#123;ServiceException.class, FileUploadException.class&#125;)</span> <span class="hljs-comment">// 用于统一处理抛出的异常</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> JsonResult&lt;Void&gt; <span class="hljs-title">handleException</span><span class="hljs-params">(Throwable e)</span></span>&#123;<br>    JsonResult&lt;Void&gt; result = <span class="hljs-keyword">new</span> JsonResult&lt;&gt;(e);<br>    <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> UsernameDuplicatedException)&#123;<br>        result.setState(<span class="hljs-number">4000</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> InsertException)&#123;<br>        result.setState(<span class="hljs-number">5000</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> UsernameNotFoundException)&#123;<br>        result.setState(<span class="hljs-number">5001</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> PasswordNotMatchException)&#123;<br>        result.setState(<span class="hljs-number">5002</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> UpdateException)&#123;<br>        result.setState(<span class="hljs-number">5003</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> FileEmptyException)&#123;<br>        result.setState(<span class="hljs-number">6000</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> FileOverSizedException)&#123;<br>        result.setState(<span class="hljs-number">6001</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> FileTypeException)&#123;<br>        result.setState(<span class="hljs-number">6002</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> FileUploadIOException)&#123;<br>        result.setState(<span class="hljs-number">6003</span>);<br>    &#125;<br>    result.setMessage(e.getMessage());<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>好家伙，你看这代码，你快乐不，是不是很快乐？等到之后项目产生的异常比较多的时候再对if-else进行重构的时候就会出现很多问题，反正很不方便。首先我们对代码进行一个review，捕获异常，根据异常类型进行返回不同的状态码。很容易就观察到，每一个if-else进行的工作都相同，那么可以将一个一个的if-else看成一个又一个的策略，这些策略完成的任务基本是相同的，那么我们的架构就可以是一个接口多个实现。现在这一部分处理完了，我们再有新的异常抛出就可以新建类实现定义的接口，很大程度上能够避免控制层的修改。现在的问题就是怎么让webapp自动抉择策略用于处理异常</p><h2 id="工厂模式"><a class="header-anchor" href="#工厂模式">¶</a>工厂模式</h2><p>工厂模式其实类比现有的工厂，工厂将原料转化为产品。在OOP中，工厂模式就是代替new进行创建对象的过程，是一种比较常见的实例化对象的方式。上一步对策略模式的分析表示最后少一步让策略自动选择，而这些策略是一个一个类，实际执行的是我们实现的接口方法。也就是说我们需要根据异常类型实例化对应的策略类，执行该策略类的接口方法。这些策略类有相同的接口，可以通过一个策略工厂进行实例化策略类的对象。</p><h2 id="一些细节"><a class="header-anchor" href="#一些细节">¶</a>一些细节</h2><p>现在还有一个问题，就是我们需要将这些策略类和一个个异常类进行对应，每一个异常都是不一样的。我们很容易的想到的就是区分类的方式就是通过类名进行区分每一个类，那我们就可以是用注解Component对每一个策略类进行注解，这样这些策略类都会注册到Spring Boot程序中，另外Component注解还有一个属性value，我们可以使用每一个异常类的名称配置策略类Component注解，那么异常和异常处理策略就对应起来了。</p><blockquote><p>这一部分我没有想到什么好的办法对其进行对应，索性就是用异常名称了，欢迎大佬在评论区进行指教</p></blockquote><p>最后策略工厂通过传入的异常名称进行匹配获取策略并创建运行其接口方法最终完成异常处理。异常名称与策略类使用键值对的形式储存在Map中。全部实现后的handleException方法如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler(&#123;ServiceException.class, FileUploadException.class&#125;)</span> <span class="hljs-comment">// 用于统一处理抛出的异常</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> JsonResult&lt;Void&gt; <span class="hljs-title">handleException</span><span class="hljs-params">(Throwable e)</span></span>&#123;<br>    JsonResult&lt;Void&gt; result = <span class="hljs-keyword">new</span> JsonResult&lt;&gt;(e);<br>    ExceptionSettleStrategy settlementInstance = strategyFactory.getSettlementInstance(e.getClass().getSimpleName());<br>    result.setState(settlementInstance.getResult());<br>    result.setMessage(e.getMessage());<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>清爽多了吧</p><h2 id="整体架构"><a class="header-anchor" href="#整体架构">¶</a>整体架构</h2><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/20220224203717.png" alt="整体架构图"></p><blockquote><p>上述架构并没有将策略全部画出</p></blockquote><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/20220224204018.png" alt="策略类"></p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/20220224204123.png" alt="异常"></p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><h3 id="异常处理策略接口"><a class="header-anchor" href="#异常处理策略接口">¶</a>异常处理策略接口</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lxl.store.strategy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExceptionSettleStrategy</span> </span>&#123;<br>    <span class="hljs-function">Integer <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="部分策略类"><a class="header-anchor" href="#部分策略类">¶</a>部分策略类</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lxl.store.strategy;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiXianLei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span> 2022/01/22 23:54</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component(value = &quot;UsernameNotFoundException&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernameNotFoundStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExceptionSettleStrategy</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5001</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="策略工厂"><a class="header-anchor" href="#策略工厂">¶</a>策略工厂</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lxl.store.strategy;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiXianLei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span> 2022/01/23 00:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionSettleStrategyFactory</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ExceptionSettleStrategy&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ExceptionSettleStrategy <span class="hljs-title">getSettlementInstance</span><span class="hljs-params">(String name)</span></span>&#123;<br>        ExceptionSettleStrategy ess = map.get(name);<br>        <span class="hljs-keyword">if</span>(ess == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;未定义异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ess;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现实编程过程中会出现很多if-else叠加的场景，比如最近在编写一个Spring Boot项目，在服务层抛出了很多异常，在控制层对服务层抛出的异常进行了处理，而对于Spring Boot项目而言，能够使用ExceptionHandler注解直接捕获所有抛出的异常，但是在进行</summary>
      
    
    
    
    <category term="Programming Language" scheme="https://conquerorlei.github.io/categories/Programming-Language/"/>
    
    <category term="Java" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/"/>
    
    <category term="Apply" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/Apply/"/>
    
    <category term="FrameWork" scheme="https://conquerorlei.github.io/categories/FrameWork/"/>
    
    <category term="SpringBoot" scheme="https://conquerorlei.github.io/categories/FrameWork/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="https://conquerorlei.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>RPC实现原理深入分析</title>
    <link href="https://conquerorlei.github.io/posts/e91a2fa5/"/>
    <id>https://conquerorlei.github.io/posts/e91a2fa5/</id>
    <published>2021-10-18T12:44:56.000Z</published>
    <updated>2022-02-24T12:57:59.496Z</updated>
    
    <content type="html"><![CDATA[<p>RPC产品应该是什么样的</p><h2 id="Consumer"><a class="header-anchor" href="#Consumer">¶</a>Consumer</h2><ul><li><p>连接管理</p><p>保持与服务提供长连接，用于传输请求数据也返回结果</p></li><li><p>负载均衡</p></li><li><p>请求路由</p></li><li><p>超时处理</p></li><li><p>健康检查</p></li></ul><h2 id="Provider"><a class="header-anchor" href="#Provider">¶</a>Provider</h2><ul><li>队列/线程池</li><li>超时丢弃</li><li>优雅关闭</li><li>过载保护</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RPC产品应该是什么样的&lt;/p&gt;
&lt;h2 id=&quot;Consumer&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Consumer&quot;&gt;¶&lt;/a&gt;Consumer&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;连接管理&lt;/p&gt;
&lt;p&gt;保持与服务提供长连接，用于传输请</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java &#39;==&#39;和equals的区别</title>
    <link href="https://conquerorlei.github.io/posts/6a76c857/"/>
    <id>https://conquerorlei.github.io/posts/6a76c857/</id>
    <published>2021-10-17T02:49:02.000Z</published>
    <updated>2022-02-24T12:57:59.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2><p>==和equals在java中都可以进行比较两个数据是否相同，那么这两者之间有什么区别呢？</p><h2 id=""><a class="header-anchor" href="#">¶</a>==</h2><p>首先需要明确的是，==符号可以用来比较基本数据类型和引用数据类型之间的。</p><ol><li>如果比较的是基本数据类型变量，那么不一定需要两个变量的类型相同，因为<font color='red'>存在基本数据类型之间的类型提升</font>(需要注意，关于boolean需要特别注意)</li><li>如果比较的是引用数据类型，那么比较的是两个对象在内存中存储的地址是否相同，即<font color='red'>两个对象是否指向同一个对象实体</font></li></ol><p>关于==运算符，尽管泛泛地可以认为是上述规则，但是对于String类型的对象，由于其创建的方式有两种，所以是有一部分的特别之处，具体请参考：<a href="https://conquerorlei.github.io/posts/173a1aaf/">Java中String、StringBuffer、StringBuilder之间的区别 - conquerorLei</a></p><h2 id="equals方法"><a class="header-anchor" href="#equals方法">¶</a>equals方法</h2><div class="note note-success">            <p>Indicate whether some other object “is equals to” this one.</p>          </div><p>在Java官方的API文档中，对Object根类中的方法的解释是泛泛的，首先我们应该确定一下几点</p><ol><li><p>equals是一个方法，而不是一个运算符</p></li><li><p>只能适用于引用数据类型而不能适用于基本数据类型</p><p>因为Java中所有的引用数据类型都继承至Object类，Object类中的方法equals()自然也就被继承下来了</p></li><li><p>Object中定义的equals方法和==符号的作用是相等的</p></li><li><p>equals方法重写之后比较的不是两个对象的地址是否相同，比较的是对象的&quot;实体内容&quot;是否相同</p></li></ol><h3 id="自定义类如何重写一个equals方法"><a class="header-anchor" href="#自定义类如何重写一个equals方法">¶</a>自定义类如何重写一个equals方法</h3><p>通常情况下，如果我们自定义类对equals方法对两个对象的实体内容是否相同，那么就需要重写equals方法</p><p>首先说明比较通用的步骤</p><ol><li>相比较两个对象的地址是否相同，如果相同直接返回true</li><li>如果传入的对象为<font color='red'>null</font>，直接返回false</li><li>判断当前类是否和传入对象的类相同，直接使用的是<font color='red'>getclass()</font>方法，相同则接着判断，不相同返回false</li><li>继续对内部的属性进行是否相同的判断，<font color='lawngreen'>首先需要做的是强制类型转换</font>，因为这个时候我们已经可以确定传入参数的类了，对内部的属性判断的过程是一个相同的过程，主要是分为基本数据类型和引用数据类型的判断。</li><li>如果上述的判断过程都没有返回true，那么直接返回false。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == obj)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (getClass() != obj.getClass())<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    GeometricObject other = (GeometricObject) obj;<br>    <span class="hljs-keyword">if</span> (color == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (other.color != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!color.equals(other.color))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (Double.doubleToLongBits(weight) != Double.doubleToLongBits(other.weight))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="主要区别"><a class="header-anchor" href="#主要区别">¶</a>主要区别</h2><p>$$\begin{array}{l|rr}比较类型 &amp; == &amp; equals\\hline基本数据类型 &amp; 比较值的大小 &amp; {\color{red} 不可比较}\引用数据类型 &amp; 地址值是否相同 &amp; 可以通过重写的方法确定实体内容是否相同\end{array}$$</p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;¶&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;==和equals在java中都可以进行比较两个数据是否相同，那么这两者之间有什么区别呢？&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;header</summary>
      
    
    
    
    <category term="Programming Language" scheme="https://conquerorlei.github.io/categories/Programming-Language/"/>
    
    <category term="Java" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/"/>
    
    <category term="Base" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/Base/"/>
    
    
    <category term="Sundry" scheme="https://conquerorlei.github.io/tags/Sundry/"/>
    
    <category term="OOP" scheme="https://conquerorlei.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Pandoc引擎渲染下出现图片两个caption的问题</title>
    <link href="https://conquerorlei.github.io/posts/d430231f/"/>
    <id>https://conquerorlei.github.io/posts/d430231f/</id>
    <published>2021-10-16T02:01:45.000Z</published>
    <updated>2021-10-16T03:13:29.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h2><p>为什么使用<code>Pandoc</code>？因为<code>Hexo</code>的页面渲染器并不是都支持<code>LeTex</code>数学公式的渲染，最开始使用的是<code>hexo-renderer-kramed</code>，但是之后再进行对<code>LeTex</code>编写的表格进行渲染的时候，出现了<font color='red'>Misplaced \hline</font>报错，但是在Typora中公式没有显示异常，而且根据<code>LeTex</code>官方文档中关于Array的描述中，是允许出现<code>\hline</code>的，于是我便注意到可能还<code>Kramed</code>对<code>\</code>的转义不全的问题。对此，我修改过<code>Kramed js</code>中的某一部分源码，但是很明显不太管用。</p><p>于是我开始尝试使用<code>hexo-renderer-pandoc</code>去渲染页面。</p><p>在我意料之中，<code>pandoc</code>很强大，直接可以渲染出<code>\hline</code>。但是随之而来的问题的图片渲染出现了问题。</p><p><code>pandoc</code>对于图片渲染的问题主要发生在<code>css</code>样式和图注上，最主要的特征就是图片没有按照样式居中，另外图注出现了两次，一次是按照我规定的样式居中显示的，一次是和正文一样，居左显示的，显然，这是很丑的。那我应该怎么去避免呢</p><h2 id="问题分析"><a class="header-anchor" href="#问题分析">¶</a>问题分析</h2><p>关于此问题的描述，最开始我是提交在Fluid Github仓库的Issue：<a href="https://github.com/fluid-dev/hexo-theme-fluid/issues/597">使用pandoc引擎出现图片渲染两个caption问题 · Issue #597 · fluid-dev/hexo-theme-fluid (github.com)</a>，最后我竟然自己通过翻文档解决了</p><p>是这样的，我当时测试是在本地测试的，并没有部署到<code>Github</code>上，这也就是给了我对比的内容。我经过两个对比，单线<code>Kramed</code>将图渲染成了<code>&lt;p&gt;</code>标签，但是<code>Pandoc</code>将图渲染成了<code>&lt;figure&gt;</code>标签，并且多了一个<code>&lt;figcaption&gt;</code></p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110161040056.png" alt="问题图像"></p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110161045401.png" alt="对比图">很明显发现，问题图像出现的问题一个是标签不一样，另外一个由于<code>&lt;figure&gt;</code>的性质，多出现一个标签<code>&lt;figcaption&gt;</code>，与其中一个<code>&lt;p class = 'image-caption'&gt;</code>重复。这样的话，就出现了一个样式的问题。怎么解决呢？</p><h2 id="解决方案"><a class="header-anchor" href="#解决方案">¶</a>解决方案</h2><p>其实最开始想到的应该是，让两个标签的样式一致，但是这个时候出现的问题很是奇怪。首先如果对图片进行以下处理，也就是对题目进行空处理，就不会出现两个标题的问题，但是，我的文件太多，我有不想一一修改，而且，还需要对项目样式文件进行修改，或者添加自定义的<code>css</code>文件，前端小白的我，有点不太想写。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">![](图片路径)<br></code></pre></div></td></tr></table></figure><p>哪有什么其他的解决方案呢？</p><p>好家伙，翻看了一堆关于<code>Pandoc</code>的文档，终于在<code>Pandoc</code>的官方文档中找到了答案。以下是我捕捉到的一些关于<code>Pandoc</code>的特性的信息，首先是关于<font color='lawngreen'>Extensions</font>，由于<code>Pandoc</code>功能实现强大，我们只能采用<code>Pandoc</code>提供的一种特别的方式进行<code>Pandoc</code>渲染避免操作。这个操作是通过删除<a href="https://pandoc.org/MANUAL.html#extensions">Extensions</a>，实现的,其中对于<font color='lawngreen'>Extensions</font>功能表述为</p><blockquote><p>The behavior of some of the readers and writers can be adjusted by enabling or disabling various extensions.</p></blockquote><p>翻译过来也就是：<font color='orange'>可以通过启用或禁用各种扩展来调整一些读写器和写入器的行为。</font>关于参数<code>implicit_figures</code>则是参考以下链接获得的<a href="https://pandoc.org/MANUAL.html#images">Pandoc’s Markdown:Images</a></p><p>这样的话，只需要在项目配置结点中添加以下内容即可以避免图片被渲染成<code>&lt;figure&gt;</code></p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">pandoc:</span><br>  <span class="hljs-attr">extensions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;-implicit_figures&#x27;</span><br></code></pre></div></td></tr></table></figure><div class="note note-primary">            <p>注意减号，默认情况下是有此后缀的，去掉此后缀才可以避免渲染成<code>&lt;figure&gt;</code></p>          </div><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#问题描述&quot;&gt;¶&lt;/a&gt;问题描述&lt;/h2&gt;
&lt;p&gt;为什么使用&lt;code&gt;Pandoc&lt;/code&gt;？因为&lt;code&gt;Hexo&lt;/code&gt;的页面渲染器并不是都支持&lt;code&gt;LeTex&lt;/c</summary>
      
    
    
    
    <category term="环境搭建" scheme="https://conquerorlei.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Hexo" scheme="https://conquerorlei.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://conquerorlei.github.io/tags/Hexo/"/>
    
    <category term="Fluid" scheme="https://conquerorlei.github.io/tags/Fluid/"/>
    
    <category term="Pandoc" scheme="https://conquerorlei.github.io/tags/Pandoc/"/>
    
  </entry>
  
  <entry>
    <title>Java对象拷贝</title>
    <link href="https://conquerorlei.github.io/posts/992ddf57/"/>
    <id>https://conquerorlei.github.io/posts/992ddf57/</id>
    <published>2021-10-13T13:54:52.000Z</published>
    <updated>2021-10-15T02:23:18.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2><p>按照惯性思维，我们总喜欢在Java中使用赋值操作完成拷贝操作。但是对于引用类型的数据，直接使用等号复制的仅仅是一个引用，此时如果我们对其中一个进行更改，另外一个也会接着更改，因为本质上这两个就是引用的同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.conquerorlei.test;<br><br><span class="hljs-keyword">import</span> com.conquerorlei.bean.Student;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CopyTest</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Student stu1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Sombody&quot;</span>,<span class="hljs-string">&quot;male&quot;</span>,<span class="hljs-number">21</span>,<span class="hljs-number">98.0</span>);<br>Student stu2 = stu1;<br><span class="hljs-comment">// 只改变一个对象的值</span><br>stu2.setGrade(<span class="hljs-number">15.0</span>);<br><br>System.out.println(stu2.toString());<br>System.out.println(stu1.toString());<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110142325012.png" alt="结果展示"></p><p>那么如何得到一个对象的副本呢？</p><p>如果说创建一个对象的新的副本，也就是说他们的起始状态完全一样，但是以后可以改变它们各自的状态而互不影响，怎么去创建呢？ – 对象拷贝</p><p>Java对象拷贝分为两种，一种是浅拷贝，一种是深拷贝</p><h2 id="浅拷贝"><a class="header-anchor" href="#浅拷贝">¶</a>浅拷贝</h2><p>需要拷贝的对象实现<code>Cloneable</code>接口，在调用对象的<code>clone</code>方法就可以实现浅拷贝</p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110150842788.png" alt="实现Cloneable"></p><div class="note note-primary">            <p>由于我的Student类并不知道直接继承至Object，中间还继承了类Person，需要在实现的方法中重写<code>clone</code>方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>clone机制不是强类型的机制，比如实现了Cloneable并没有强制要求继承链上的对象也实现；</p><p>也没有强制要求覆盖clone方法。</p>          </div><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"> <span class="hljs-comment">// data</span><br><span class="hljs-keyword">package</span> com.conquerorlei.bean;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br><span class="hljs-keyword">private</span> Grade grade;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,String name,String sex,<span class="hljs-keyword">int</span> age,Grade grade)</span> </span>&#123;<br><span class="hljs-keyword">super</span>(id,name,sex,age);<br><span class="hljs-keyword">this</span>.grade = grade;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGrade</span><span class="hljs-params">(Grade grade)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.grade = grade;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Grade <span class="hljs-title">getGrade</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> grade;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString() + <span class="hljs-string">&quot;[grade=&quot;</span> + <span class="hljs-keyword">this</span>.grade.toString() + <span class="hljs-string">&quot;]&quot;</span>; <br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>以下即为我的测试</p><div class="note note-primary">            <p>需要注意的是，浅拷贝并不会对内部引用对象进行拷贝，以下案例充分说明了这一点</p>          </div><p>非关键类存放在附录中</p><p>此时的grade是一个对象，其余的数据域是基本数据类型和引用类型String</p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110150858005.png" alt="内部对象"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.conquerorlei.test;<br><br><span class="hljs-keyword">import</span> com.conquerorlei.bean.Student;<br><span class="hljs-keyword">import</span> com.conquerorlei.bean.Grade;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CopyTest</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>&#123;<br>Student stu1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Somebody&quot;</span>,<span class="hljs-string">&quot;male&quot;</span>,<span class="hljs-number">21</span>,<span class="hljs-keyword">new</span> Grade(<span class="hljs-number">98.0</span>,<span class="hljs-number">97.5</span>,<span class="hljs-number">85.7</span>));<br>Student stu2 = (Student)stu1.clone();<br><span class="hljs-comment">// 只改变一个对象的值</span><br>         stu2.setName(<span class="hljs-string">&quot;Newone&quot;</span>);<br>stu2.getGrade().setChinese(<span class="hljs-number">65.9</span>);;<br><br>System.out.println(stu1.toString());<br>System.out.println(stu2.toString());<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时的测试结果是这样的，是有问题的</p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110150901312.png" alt="有问题的结果"></p><div class="note note-success">            <p>解释：浅拷贝并不会对其对象中引用的对象进行拷贝；</p><p>如果类中没有特殊的引用数据类型，可以考虑浅拷贝。</p>          </div><p>需要注意的是，<font color='red'>其中的String是个例外</font>，虽然也是引用数据类型，但是确实可以进行浅拷贝</p><div class="note note-primary">            <p>String类型通过常量赋值时相当于基本数据类型，通过new关键字创建对象时便是引用数据类型</p>          </div><p>为什么拷贝不会拷贝其引用的对象？</p><ol><li><p>不需要给其他类强加定义</p><p>Student类实现了接口Cloneable但是Grade并没有实现，如果在拷贝Student的情况下同时也把Grade拷贝了，这不就是对Grade强加定义吗</p></li><li><p>不破坏其原来代码的逻辑</p><p>如果Grade是一个单例模式的对象，那么在拷贝外部引用他的对象Student对Grade进行了拷贝，那就是违背了Grade设计的逻辑初衷</p></li></ol><p>如果要实现完整的深拷贝，那么就需要在继承链和引用链上实现Cloneable并完成clone方法重写，这样就比较麻烦了</p><h2 id="深拷贝"><a class="header-anchor" href="#深拷贝">¶</a>深拷贝</h2><p>深拷贝和浅拷贝不同的是，<font color='orange'>深拷贝会把拷贝的对象和其引用的对象都重新生成新的对象</font>。</p><p>对象实现序列化接口，并在类中实现deepClone方法，将this写入流，再读出来。俗称：<font color='lawngreen'>冷冻-解冻</font>。以下为实现后的代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.conquerorlei.bean;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.io.PipedInputStream;<br><span class="hljs-keyword">import</span> java.io.PipedOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>,<span class="hljs-title">Serializable</span></span>&#123;<br><span class="hljs-keyword">private</span> Grade grade;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,String name,String sex,<span class="hljs-keyword">int</span> age,Grade grade)</span> </span>&#123;<br><span class="hljs-keyword">super</span>(id,name,sex,age);<br><span class="hljs-keyword">this</span>.grade = grade;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGrade</span><span class="hljs-params">(Grade grade)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.grade = grade;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Grade <span class="hljs-title">getGrade</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> grade;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString() + <span class="hljs-string">&quot;[grade=&quot;</span> + <span class="hljs-keyword">this</span>.grade.toString() + <span class="hljs-string">&quot;]&quot;</span>; <br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用序列化对本类进行深层拷贝，拷贝包括其中引用的对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.comqueror.bean.Student</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">deepClone</span><span class="hljs-params">()</span> </span>&#123;<br>Student s2 = <span class="hljs-keyword">null</span>;<br>Student s1 = <span class="hljs-keyword">this</span>;<br>PipedOutputStream out = <span class="hljs-keyword">new</span> PipedOutputStream();<br>PipedInputStream in = <span class="hljs-keyword">new</span> PipedInputStream();<br><span class="hljs-keyword">try</span> &#123;<br>in.connect(out);<br>&#125;<span class="hljs-keyword">catch</span>(IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span>(ObjectOutputStream bo = <span class="hljs-keyword">new</span> ObjectOutputStream(out);<br>ObjectInputStream bi = <span class="hljs-keyword">new</span> ObjectInputStream(in);)&#123;<br>bo.writeObject(s1);<br>s2 = (Student) bi.readObject(); <br>&#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">return</span> s2;<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><div class="note note-warning">            <p>被拷贝对象的继承联，引用链上的每一个对象都需要实现<code>Serializable</code>。不需要实现任何方法</p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110150956281.png" alt="实现序列化的父类Person"></p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110150957998.png" alt="实现序列化的引用类Grade"></p>          </div><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p>其余类的代码</p><p><strong>Peron</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.conquerorlei.bean;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> String sex;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name,String sex,<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.sex = sex;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> id;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.sex = sex;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> sex;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot; [id=&quot;</span> + id + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;, sex=&quot;</span> + sex + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Grade</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.conquerorlei.bean;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grade</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> chinese;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> math;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> english;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Grade</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Grade</span><span class="hljs-params">(<span class="hljs-keyword">double</span> chinese,<span class="hljs-keyword">double</span> math,<span class="hljs-keyword">double</span> english)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.chinese = chinese;<br><span class="hljs-keyword">this</span>.math = math;<br><span class="hljs-keyword">this</span>.english = english;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChinese</span><span class="hljs-params">(<span class="hljs-keyword">double</span> chinese)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.chinese = chinese;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getChinese</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> chinese;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMath</span><span class="hljs-params">(<span class="hljs-keyword">double</span> math)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.math = math;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getMath</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> math;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnglish</span><span class="hljs-params">(<span class="hljs-keyword">double</span> english)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.english = english;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEnglish</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> english;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName() + <br><span class="hljs-string">&quot;[chinese=&quot;</span> + chinese +<br><span class="hljs-string">&quot;, math=&quot;</span>+math +<br><span class="hljs-string">&quot;, english=&quot;</span>+ english +<span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><hr><p>除了上述的方法之外还有没有其他的方法进行对象拷贝？</p><p><font color='red'>未完待续</font></p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;¶&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;按照惯性思维，我们总喜欢在Java中使用赋值操作完成拷贝操作。但是对于引用类型的数据，直接使用等号复制的仅仅是一个引用，此时如果我们对其中一个进行更改，</summary>
      
    
    
    
    <category term="Programming Language" scheme="https://conquerorlei.github.io/categories/Programming-Language/"/>
    
    <category term="Java" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/"/>
    
    <category term="Base" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/Base/"/>
    
    
    <category term="OOP" scheme="https://conquerorlei.github.io/tags/OOP/"/>
    
    <category term="Base" scheme="https://conquerorlei.github.io/tags/Base/"/>
    
  </entry>
  
  <entry>
    <title>Java中String、StringBuffer、StringBuilder之间的区别</title>
    <link href="https://conquerorlei.github.io/posts/173a1aaf/"/>
    <id>https://conquerorlei.github.io/posts/173a1aaf/</id>
    <published>2021-10-13T08:01:57.000Z</published>
    <updated>2021-10-15T10:15:21.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2><p>String是常用的类，也是面试经常问到的类</p><p>StringBuffer和StringBuilder是两个操作字符串的类</p><p>说明：以下代码运行结果均使用Eclipse运行代码获得</p><h2 id="String"><a class="header-anchor" href="#String">¶</a>String</h2><p>String是final修饰的，因此<font color='red'>不可以被继承</font></p><p>字符串在Java中不可变的，因此<font color='orange'>适合在多线程下使用</font></p><h3 id="创建"><a class="header-anchor" href="#创建">¶</a>创建</h3><p>在我们使用双引号创建一个字符串的时候，JVM首先在字符串池中寻找具有相同的值的字符串。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">String str = <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>如果找到了则返回字符串池字符串对象的引用。否则，他会在字符串中创建字符串对象并返回引用。<font color='lawngreen'>JVM通过在不同的线程中引用相同的对象，节省了大量的内存</font></p><p>如果使用new运算符创建字符串，则会在堆中创建它。也就是，使用new和直接使用双引号创建对象是不一样的，存储位置都不一样的，以下为一个测试</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.conquerorlei.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 字符串常量池中</span><br>String str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>String str2 = <span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.println(str1 == str2);<br><span class="hljs-comment">// 堆上</span><br>String str3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>System.out.println(str1 == str3);<br><span class="hljs-comment">// 使用equals进行判断时在各种都相同的比较内部值是否相同</span><br>System.out.println(str1.equals(str3));<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>结果输出：</strong></p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110131631076.png" alt="结果"></p><div class="note note-success">            <p>两个字符串只有在他们具有相同字符的时候才会想等，equals方法是区分大小写的，如果不想区分大小写，应该使用equalsIgnoreCase方法。</p>          </div><h3 id="冒牌的魔法：运算符-以及"><a class="header-anchor" href="#冒牌的魔法：运算符-以及">¶</a>冒牌的魔法：运算符+以及+=</h3><p>运算符<code>+</code>是为字符串重载的，可以使用<code>+</code>进行字符串拼接。但是，在这个运算的内部是通过<code>StringBuilder</code>执行拼接动作的。</p><p>其实Java中是没有重载概念的，但是这里的String中的+、=都有点类似C++中的运算符重载，这是为什么？</p><p>其实，这只不过是Java编译器做了一些手脚</p><p>例如对于以下语句</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>String str2 = str + <span class="hljs-string">&quot;def&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>编译的过程中会自动转化为以下语句</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>String str2 = (<span class="hljs-keyword">new</span> StringBuilder(String.valueof(str1))).append(<span class="hljs-string">&quot;def&quot;</span>).toString();<br></code></pre></div></td></tr></table></figure><h2 id="拼接字符串"><a class="header-anchor" href="#拼接字符串">¶</a>拼接字符串</h2><p>由于String在Java是不可变的，所以每次当我们执行字符串拼接的时候时，都会生成一个新的String并丢弃旧的String。这些重复的操作将会产生大量的垃圾冗余。</p><p>所以Java提供了StringBuilder和StringBuffer类，应用于字符串操作。</p><p>StringBuffer和StringBuilder是java中的可变对象，提供了append、insert、delete、substring方法</p><h3 id="StringBuffer和StringBuilder区别"><a class="header-anchor" href="#StringBuffer和StringBuilder区别">¶</a>StringBuffer和StringBuilder区别</h3><p>$$\begin{array}{c|rr}Difference &amp; StringBuffer &amp; StrignBuilder\\hline线程 &amp; 安全 &amp; 不安全\同步 &amp; 同步 &amp; 不同步\速度 &amp; 慢 &amp; 快\出现版本 &amp; 始于Java1.0 &amp; 始于Java1.5\end{array}$$</p><p>在Java1.4之前，StringBuffer是字符串操作的唯一选择。<font color='red'>StringBuffer既是缺点又是优点的地方在于它的所有的方法都是同步的</font>。StringBuffer提供线程安全，但是是以性能为代价的。</p><p>而StringBuilder除了不是同步线程不安全之外和StringBuffer是一样的，他和StringBuffer类似。</p><div class="note note-primary">            <p>如果是在单线程环境或者无关线程安全的情况下要使用StringBuilder，这种情况下效率才是王者。</p>          </div><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;¶&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;String是常用的类，也是面试经常问到的类&lt;/p&gt;
&lt;p&gt;StringBuffer和StringBuilder是两个操作字符串的类&lt;/p&gt;
&lt;p&gt;说明</summary>
      
    
    
    
    <category term="Programming Language" scheme="https://conquerorlei.github.io/categories/Programming-Language/"/>
    
    <category term="Java" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/"/>
    
    <category term="Base" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/Base/"/>
    
    
    <category term="Base" scheme="https://conquerorlei.github.io/tags/Base/"/>
    
  </entry>
  
  <entry>
    <title>慧策面试经验(待更新)</title>
    <link href="https://conquerorlei.github.io/posts/977185ad/"/>
    <id>https://conquerorlei.github.io/posts/977185ad/</id>
    <published>2021-10-13T07:40:44.000Z</published>
    <updated>2021-10-15T02:27:56.768Z</updated>
    
    <content type="html"><![CDATA[<h1>10/13 第一次面试</h1><h2 id="Java基础"><a class="header-anchor" href="#Java基础">¶</a>Java基础</h2><ol><li>== 和equals的区别？equals中使用了那个方法，HashCode方法得到的Hash值相等是否就代表两个对象相等</li><li>用过哪些和字符串操作相关的类，<a href="http://conquerorlei.github.io/posts/173a1aaf/">String，StringBudilder，StringBuffer之间的区别</a>，StringBuilder和StringBuffer谁是线程安全的？</li><li>HashMap的底层数据结构，HashMap默认加载因子为多少，假如现在要存入1000个值到HashMap，初始化时需要初始化的长度为多大。HashMap的put过程</li><li>对<a href="https://conquerorlei.github.io/posts/992ddf57/">对象拷贝</a>有过了解吗</li></ol><h2 id="框架"><a class="header-anchor" href="#框架">¶</a>框架</h2><p>关于框架了解不多，他问的也不多</p><ol><li>IOP和AOP</li><li>Maven有哪些功能，让你觉得比较便利的功能有哪些</li></ol><h2 id="MySQL"><a class="header-anchor" href="#MySQL">¶</a>MySQL</h2><ol><li>MySQL聚簇索引和非聚簇索引</li><li>InnoDB的底层数据结构</li><li>MySQL的事务隔离级别以及ACID特性</li></ol><h2 id="算法"><a class="header-anchor" href="#算法">¶</a>算法</h2><ol><li>1-100之间的不重复的的数字存入array[99]中，其中有一个缺失的数，如何确定这个数字</li><li>list删除指定元素，从头循环会有漏删的情况，有什么其他的方法</li><li>产生一个6位的随机数，要求这个随机数必须至少有一个数字是重复的，并且不能挨着</li></ol><hr><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;10/13 第一次面试&lt;/h1&gt;
&lt;h2 id=&quot;Java基础&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Java基础&quot;&gt;¶&lt;/a&gt;Java基础&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;== 和equals的区别？equals中使用了那个方法，HashCode</summary>
      
    
    
    
    <category term="面试经验" scheme="https://conquerorlei.github.io/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="面经" scheme="https://conquerorlei.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="https://conquerorlei.github.io/posts/13c31df7/"/>
    <id>https://conquerorlei.github.io/posts/13c31df7/</id>
    <published>2021-10-12T08:25:54.000Z</published>
    <updated>2021-10-12T11:53:08.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a class="header-anchor" href="#题目地址">¶</a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h3 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h3><p><strong>暴力法</strong></p><p>最长回文子串，听着名字就知道不好惹，首先，如果采用我最开始的思路，就是获取所有的子串然后对每一个子串进行回文判断，首先就应该是两个循环嵌套确定子串边界，然后在循环内部进行回文串判定，这样的话时间复杂度直接飙升O(n<sup>3</sup>)，判题可能不会通过。</p><p>如何较少一层循环呢？</p><p><strong>中心扩散</strong></p><p>后来想了想，既然第二层循环是确定右边界的，第一层循环是确定左边界的，那为什么不可以不确定边界，只设置一层循环确定中心位置，由中心位置向两侧扩散，获取以此为中心位置最长的回文字符串，记录中心位置并计算出开始位置，这样的话就减少了一层循环，由于中心位置不需要检测最左边界以及最后边界，所以最多只有2(n-1)个中心位置。这样的话，直接就降低了一个数量级的时间复杂度，直接变为O(n<sup>2</sup>)</p><p>为什么是2(n-1)?</p><p>因为在进行扩散的时候，不能单单进行中心位置那一个点的判断，还需要以两个相邻的点作为中心位置进行扩散，为什么？</p><div class="note note-info">            <p>考虑以下字符串：<font color='red'>baab</font></p><p>按照上述算法，如果考虑单个点作为中心位置，那么输出的结果就是<font color='orange'>aa</font>而正确答案却是<font color='lawngreen'>baab</font></p>          </div><p>其实，单个点作为中心位置对长度为奇数的字符串很友好，两个点为中心位置对长度为偶数的字符串很友好。出于全面考虑，必须按照这样做才能覆盖全部情况</p><h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3><h4 id="暴力法"><a class="header-anchor" href="#暴力法">¶</a>暴力法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxLenth = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">char</span>[] c = s.toCharArray();<br>        <span class="hljs-keyword">int</span> len = c.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len - <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; len;j++)&#123;<br>                <span class="hljs-keyword">if</span>(isPlalindrome(c,i,j) &amp;&amp; maxLenth &lt; j - i + <span class="hljs-number">1</span>)&#123;<br>                    begin = i;<br>                    maxLenth = j - i + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(begin, begin + maxLenth);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断回文串charArray[left...right]是不是回文字符串</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPlalindrome</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] charArray,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-keyword">if</span>(charArray[left] != charArray[right])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110121708273.png" alt="暴力刷题结果"></p><div class="note note-info">            <p>令我没有想到的是暴力法刷题竟然通过了，有点不太leetcode啊，有木有？</p>          </div><h4 id="中心扩散法"><a class="header-anchor" href="#中心扩散法">¶</a>中心扩散法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">char</span>[] c = s.toCharArray();<br>        <span class="hljs-keyword">int</span> len = c.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len - <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">int</span> len1 = exapndFromCenter(c,i,i);<br>            <span class="hljs-keyword">int</span> len2 = exapndFromCenter(c,i,i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> max = Math.max(len1,len2);<br>            <span class="hljs-keyword">if</span>(max &gt; maxLen)&#123;<br>                begin = i - (max + <span class="hljs-number">1</span>)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                maxLen = max;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(begin,begin + maxLen);<br>    &#125;<br><br>    <span class="hljs-comment">//中心扩散求中心最大子串</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">exapndFromCenter</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] c,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; c.length)&#123;<br>            <span class="hljs-keyword">if</span>(c[left] == c[right])&#123;<br>                left--;<br>                right++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><div class="note note-primary">            <p>可能有部分小伙伴对上述代码中的第16行也就是<code>begin</code>的确定方法有点疑惑，这里说明一下</p><p>首先i是中心位置，我们求出来了以<code>i</code>为中心位置的最大回文子串的长度<code>max</code>，如何确定起始位置<code>begin</code>呢？想法其实很简单，直接用i减去max的一半不就好了，但是需要注意需要加一个1，这个原因就不用多说了。有细心的小伙伴可能立马发现了为什么你写的不是<code>(max + 1)/2</code>?</p><p>因为我们是有两种情况的，一种是以单个点为中心位置，一种是以两个点为中心位置，看一下两个例子</p><ol><li><p><font color='red'>acbdaadb</font></p></li><li><p><font color='red'>acbdadb</font></p></li></ol><p>很显然，无论是哪一个，<code>i = 4</code>，<code>begin = 2</code>，只不过<code>max</code>不一样，<code>max1</code>为6，<code>max2</code>为5，如果要是使用上述的公式也就是<code>i - max / 2 +1</code>，那么两个的结果就是不一样的，但是可以很明显知道，<code>max = 6</code> 时<code>begin</code>的位置是正确的；另外我们也知道6和7除以2结果是一样的，所以就是用了<code>(max + 1)/2</code></p>          </div><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110121805265.png" alt="中心扩散法力扣提交结果"></p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目地址&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目地址&quot;&gt;¶&lt;/a&gt;题目地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substrin</summary>
      
    
    
    
    
    <category term="Programming Language,Java,Apply" scheme="https://conquerorlei.github.io/tags/Programming-Language-Java-Apply/"/>
    
    <category term="Algorithm,中心扩散法" scheme="https://conquerorlei.github.io/tags/Algorithm-%E4%B8%AD%E5%BF%83%E6%89%A9%E6%95%A3%E6%B3%95/"/>
    
    <category term="Algorithm,暴力法" scheme="https://conquerorlei.github.io/tags/Algorithm-%E6%9A%B4%E5%8A%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>非负整数字符串相加</title>
    <link href="https://conquerorlei.github.io/posts/b75c4dbd/"/>
    <id>https://conquerorlei.github.io/posts/b75c4dbd/</id>
    <published>2021-10-12T00:37:04.000Z</published>
    <updated>2021-10-12T12:05:47.872Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a class="header-anchor" href="#题目地址">¶</a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h3 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h3><p>题目中给定了要求，<font color='red'>不允许调用内库中的关于大整数运算的库</font></p><p>那也行，直接使用小学使用的竖式进行加法运算不就可以了吗？ok，理论存在，实践开始。</p><p>两数加法，我们都知道加法原则，直接就是对位相加，超10进位，对10取余拖下来</p><p><strong>不带进位加法</strong>$$\begin{array}{r}{1}\ {1} \+{1} \ {2}\ {3}\\hline{1}\ {3}\ {4}\end{array}$$<strong>带进位加法</strong>$$\begin{array}{r}4\ 5\ 6\ +\quad_17_17\ \hline 5\ 3\ 3\end{array}$$</p><p>这样的话，直接定义两个尾指针，从后依次向前遍历(每次遍历尾指针自减)，每次遍历都会对位相加，对加法结果除10作为进位，对10取余作为剩下位。</p><div class="note note-warning">            <p><font color='red'>不建议采用String s = “”;然后对s用+进行拼接的形式</font>，这样的效率实在是太低。建议直接使用<code>StringBuffer</code>或者<code>StringBuilder</code></p>          </div><h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStrings</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> p1 = num1.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> p2 = num2.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">while</span>(p1 &gt;= <span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> a = p1 &gt;= <span class="hljs-number">0</span> ? num1.charAt(p1) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> b = p2 &gt;= <span class="hljs-number">0</span> ? num2.charAt(p2) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> sum = a + b + carry;<br>            sb.append(sum % <span class="hljs-number">10</span>);<br>            carry = sum / <span class="hljs-number">10</span>;<br>            p1--;<br>            p2--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry != <span class="hljs-number">0</span>) sb.append(carry);<br>        <span class="hljs-keyword">return</span> sb.reverse().toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110120921361.png" alt="力扣结果"></p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目地址&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目地址&quot;&gt;¶&lt;/a&gt;题目地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-strings/&quot;&gt;415. 字符串相加 - 力</summary>
      
    
    
    
    <category term="Programming Language" scheme="https://conquerorlei.github.io/categories/Programming-Language/"/>
    
    <category term="Java" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/"/>
    
    <category term="Apply" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/Apply/"/>
    
    <category term="Algorithm" scheme="https://conquerorlei.github.io/categories/Algorithm/"/>
    
    <category term="模拟法" scheme="https://conquerorlei.github.io/categories/Algorithm/%E6%A8%A1%E6%8B%9F%E6%B3%95/"/>
    
    
    <category term="Daily" scheme="https://conquerorlei.github.io/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>有效括号</title>
    <link href="https://conquerorlei.github.io/posts/c774a81f/"/>
    <id>https://conquerorlei.github.io/posts/c774a81f/</id>
    <published>2021-10-11T13:33:28.000Z</published>
    <updated>2021-10-11T15:41:54.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a class="header-anchor" href="#题目地址">¶</a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h3 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h3><p>这个分析其实很简单不是嘛，但凡是牵扯到符号匹配的，考虑栈的特性先入后出，然后根据右边括号与栈顶元素的匹配情况考虑是都继续匹配</p><p>时间复杂度为O(n)，空间复杂度为O(1)</p><h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">char</span>[] c = s.toCharArray();<br>        <span class="hljs-keyword">int</span> len = c.length;<br>        <span class="hljs-keyword">char</span> temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(c[i] == <span class="hljs-string">&#x27;(&#x27;</span> || c[i] == <span class="hljs-string">&#x27;[&#x27;</span> || c[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stack.push(c[i]);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[i] == <span class="hljs-string">&#x27;)&#x27;</span> || c[i] == <span class="hljs-string">&#x27;]&#x27;</span> || c[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                temp = stack.pop();<br>                <span class="hljs-keyword">if</span>(c[i] == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; temp == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c[i] == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; temp == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; temp == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110112143386.png" alt="未优化提交结果"></p><h3 id="优化"><a class="header-anchor" href="#优化">¶</a>优化</h3><p>为什么要优化？因为内存消耗太大了，另外就是if结构太多了，代替为switch和foreach结构</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:cs)&#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stack.push(c);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">switch</span>(c)&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>                        <span class="hljs-keyword">if</span>(stack.peek() == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                            stack.pop();<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>:<br>                        <span class="hljs-keyword">if</span>(stack.peek() == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                            stack.pop();<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>:<br>                        <span class="hljs-keyword">if</span>(stack.peek() == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                            stack.pop();<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.empty();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110112333018.png" alt="优化后判题结果"></p><p>近乎100%</p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目地址&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目地址&quot;&gt;¶&lt;/a&gt;题目地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses/&quot;&gt;20. 有效的括</summary>
      
    
    
    
    <category term="Programming Language" scheme="https://conquerorlei.github.io/categories/Programming-Language/"/>
    
    <category term="Java" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/"/>
    
    <category term="Apply" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/Apply/"/>
    
    <category term="Algorithm" scheme="https://conquerorlei.github.io/categories/Algorithm/"/>
    
    
    <category term="Daily" scheme="https://conquerorlei.github.io/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 开窗函数</title>
    <link href="https://conquerorlei.github.io/posts/c9868b51/"/>
    <id>https://conquerorlei.github.io/posts/c9868b51/</id>
    <published>2021-10-10T13:04:17.000Z</published>
    <updated>2021-10-10T15:21:12.972Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开窗函数"><a class="header-anchor" href="#开窗函数">¶</a>开窗函数</h3><p>开窗函数/分析函数：over()</p><p>开窗函数是要对数据库数据进行<font color='red'>实时分析处理</font>，别称OLAP函数(分析函数)。</p><p>窗口函数的引入是为了解决想要既显示聚集前的数据,又要显示聚集后的数据。开窗函数对一组值进行操作，不需要使用GROUP BY子句对数据进行分组，能够在同一行中同时返回基础行的列和聚合列。</p><div class="note note-warning">            <p><font color='red'>MySQL8.0之后可用</font></p>          </div><h4 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">&lt;开窗函数&gt; over ([partition by &lt;列清单&gt;] [order by &lt;排序用列清单&gt;])<br></code></pre></div></td></tr></table></figure><div class="note note-success">            <ul><li><p>over(partition by xxx)：按xxx分组的所有行进行分组</p></li><li><p>over(order by aaa)：按aaa列排序</p></li><li><p>over(partition by xxx order by aaa)：按列xxx分组，按列aaa排序</p></li></ul>          </div><h4 id="分类"><a class="header-anchor" href="#分类">¶</a>分类</h4><ol><li>可以作为开窗函数的聚合函数，例如：<font color='red'>sum,count,avg,max,min</font></li><li>专用开窗函数，例如：<font color='red'>rank,row_number,dense_number</font>等；</li></ol><h4 id="开窗函数与聚合函数区别"><a class="header-anchor" href="#开窗函数与聚合函数区别">¶</a>开窗函数与聚合函数区别</h4><ol><li>SQL标准允许所有的<a href="https://conquerorlei.github.io/posts/beb41dd5/">聚合函数</a>作为开窗函数使用，需要使用over区分聚合函数和开窗函数</li><li>聚合函数每组只返回一个值，开窗函数每组可以返回多个值</li></ol><h3 id="常用的排序函数"><a class="header-anchor" href="#常用的排序函数">¶</a>常用的排序函数</h3><hr><p><font color='red'>未完成</font></p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;开窗函数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#开窗函数&quot;&gt;¶&lt;/a&gt;开窗函数&lt;/h3&gt;
&lt;p&gt;开窗函数/分析函数：over()&lt;/p&gt;
&lt;p&gt;开窗函数是要对数据库数据进行&lt;font color=&#39;red&#39;&gt;实时分析处理&lt;/font&gt;，</summary>
      
    
    
    
    <category term="Database" scheme="https://conquerorlei.github.io/categories/Database/"/>
    
    <category term="MySQL" scheme="https://conquerorlei.github.io/categories/Database/MySQL/"/>
    
    
    <category term="SQL" scheme="https://conquerorlei.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>分割字符串的最大分数</title>
    <link href="https://conquerorlei.github.io/posts/12ae4b8b/"/>
    <id>https://conquerorlei.github.io/posts/12ae4b8b/</id>
    <published>2021-10-10T07:04:19.000Z</published>
    <updated>2021-10-10T15:21:12.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a class="header-anchor" href="#题目地址">¶</a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string/">1422. 分割字符串的最大得分 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h3 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h3><p>最开始想的肯定是暴力解法，总不能看不起盲僧。但是暴力的问题就是超时。怎么去优化让它不超时呢</p><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110101515451.png" alt="如果暴力不是为了超时"></p><p>想来想去，还是贪心点好了。首先是先求出来最左分割得出的分数，同时定义两个变量a、b分别记录左边0的个数和右边1的个数，定义指针指向首个分割点；可是我贪心啊，万一后面还是有更高的分数呢？然后指针后移，每次后移都对指向的点进行0、1判断，根据判断结果增加或者减少a、b的值，每次后移都要进行最大值判断。这样的话，时间复杂度是O(n)</p><h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>,b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        <span class="hljs-keyword">if</span>(s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            a++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; len;j++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(j) == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                b++;<br>            &#125;<br>        &#125;<br>        max = a+b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; len-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                a++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                b--;<br>            &#125;<br>            max = Math.max(max,a+b);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110101549627.png" alt="image-20211010154936596"></p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目地址&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目地址&quot;&gt;¶&lt;/a&gt;题目地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-score-after-splittin</summary>
      
    
    
    
    <category term="Programming Language" scheme="https://conquerorlei.github.io/categories/Programming-Language/"/>
    
    <category term="Java" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/"/>
    
    <category term="Apply" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/Apply/"/>
    
    <category term="Algorithm" scheme="https://conquerorlei.github.io/categories/Algorithm/"/>
    
    <category term="贪心算法" scheme="https://conquerorlei.github.io/categories/Algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Daily" scheme="https://conquerorlei.github.io/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>字符串解码</title>
    <link href="https://conquerorlei.github.io/posts/31ca343a/"/>
    <id>https://conquerorlei.github.io/posts/31ca343a/</id>
    <published>2021-10-10T00:00:10.000Z</published>
    <updated>2021-10-10T15:21:12.976Z</updated>
    
    <content type="html"><![CDATA[<p>交代一下，这道题是某厂笔试题，当时直接做崩，最后一道题没写出来，通过了14%的测试用例，OJ：牛客</p><h3 id="题目地址"><a class="header-anchor" href="#题目地址">¶</a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/decode-string/">394. 字符串解码 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h3 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h3><p>当时可能时间比较紧一些，没有进行详细的分析。事后分析一下，其实也就那样</p><p>由于题目当中允许嵌套，并且有数字之类的，所以使用栈的特性进行符号判断挺好的</p><ul><li>如果字符串当前字符是数字，获取数字并压入栈</li><li>如果字符串当前字符是字母或者是’['，直接压栈</li><li>如果字符串当前字符串是’]‘，开始弹栈，直到遇见’['，作为待扩充字符串</li><li>对于’['，直接弹栈</li><li>对于数字，弹栈后作为限制条件扩充字符串</li><li>将扩充的字符串进行压栈处理，循环操作，直到遍历完字符串，然后再将栈转化为字符串输出就好了</li></ul><p>再加上一点点细节就出来啦</p><h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ptr;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decodeString</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        LinkedList&lt;String&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        ptr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(ptr&lt;len)&#123;<br>            <span class="hljs-comment">//数字判断</span><br>            <span class="hljs-keyword">if</span>(Character.isDigit(s.charAt(ptr)))&#123;<br>                stack.addLast(getNumber(s));<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//左括号判断</span><br>            <span class="hljs-keyword">if</span>(s.charAt(ptr)==<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                stack.addLast(String.valueOf(<span class="hljs-string">&#x27;[&#x27;</span>));<br>                ptr++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//字母判断</span><br>            <span class="hljs-keyword">if</span>(Character.isLetter(s.charAt(ptr)))&#123;<br>                stack.addLast(getWord(s));<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//右括号判断</span><br>            <span class="hljs-keyword">if</span>(s.charAt(ptr)==<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                ptr++;<br>                LinkedList&lt;String&gt; temp = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>                <span class="hljs-keyword">while</span>(!<span class="hljs-string">&quot;[&quot;</span>.equals(stack.peekLast()))&#123;<br>                    temp.addFirst(stack.removeLast());<br>                &#125;<br>                stack.removeLast();<br>                <span class="hljs-keyword">int</span> count = Integer.parseInt(stack.removeLast());<br>                String tmp = getString(temp);<br>                String result = <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-keyword">while</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>                    result+=tmp;<br>                    count--;<br>                &#125;<br>                stack.addLast(result);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> getString(stack);<br>    &#125;<br>    <span class="hljs-comment">// 获取数字</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNumber</span><span class="hljs-params">(String s)</span></span>&#123;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">while</span>(Character.isDigit(s.charAt(ptr)))&#123;<br>            sb.append(s.charAt(ptr++));<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <span class="hljs-comment">// 获取单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getWord</span><span class="hljs-params">(String s)</span></span>&#123;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-comment">// 最后的字符一定是字母或者&#x27;]&#x27;，需要添加边界判断</span><br>        <span class="hljs-keyword">while</span>(ptr!=s.length() &amp;&amp; Character.isLetter(s.charAt(ptr)))&#123;<br>            sb.append(s.charAt(ptr++));<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br><br>    &#125;<br>    <span class="hljs-comment">// 转化为字符串</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getString</span><span class="hljs-params">(LinkedList&lt;String&gt; str)</span></span>&#123;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">for</span>(String s:str)&#123;<br>            sb.append(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110101114965.png" alt="力扣结果"></p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;交代一下，这道题是某厂笔试题，当时直接做崩，最后一道题没写出来，通过了14%的测试用例，OJ：牛客&lt;/p&gt;
&lt;h3 id=&quot;题目地址&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目地址&quot;&gt;¶&lt;/a&gt;题目地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="Programming Language" scheme="https://conquerorlei.github.io/categories/Programming-Language/"/>
    
    <category term="Java" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/"/>
    
    <category term="Apply" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/Apply/"/>
    
    <category term="Algorithm" scheme="https://conquerorlei.github.io/categories/Algorithm/"/>
    
    <category term="贪心算法" scheme="https://conquerorlei.github.io/categories/Algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Daily" scheme="https://conquerorlei.github.io/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 刷题:第二高的薪水</title>
    <link href="https://conquerorlei.github.io/posts/e98f383e/"/>
    <id>https://conquerorlei.github.io/posts/e98f383e/</id>
    <published>2021-10-09T15:27:31.000Z</published>
    <updated>2021-10-10T15:21:12.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二高的薪水"><a class="header-anchor" href="#第二高的薪水">¶</a>第二高的薪水</h3><h4 id="题目地址"><a class="header-anchor" href="#题目地址">¶</a>题目地址</h4><p><a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h4 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h4><p>第二高的薪水，其实想过去很简单。直接使用order by语句进行一个排序操作，使用limit只选择一条，由于需要跳过第一高的薪水，那么需要使用offset。</p><p><strong>问题1</strong>：如果很多人并列第一高的薪水呢</p><p>使用distinct关键字，因为题目要求的是只输出薪水，并没有要求输出全部的排名第二的薪水</p><p><strong>问题2</strong>：如果没有第二高的薪水呢</p><p>按照题目要求，没有第二高的薪水是需要输出null的。那么使用ifnull进行判断就好了</p><h4 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># Write your MySQL query statement below<br><span class="hljs-keyword">select</span> ifnull(<br>    (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> Salary <br>    <span class="hljs-keyword">from</span> Employee<br>    <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Salary <span class="hljs-keyword">desc</span><br>    limit <span class="hljs-number">1</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">1</span>),<span class="hljs-keyword">null</span><br>) <span class="hljs-keyword">as</span> SecondHighestSalary;<br></code></pre></div></td></tr></table></figure><hr><h3 id="第N高的薪水"><a class="header-anchor" href="#第N高的薪水">¶</a>第N高的薪水</h3><p>紧跟着就是第N高的薪水，一块写了算了</p><p>题目地址：<a href="https://leetcode-cn.com/problems/nth-highest-salary/">177. 第N高的薪水 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>基本思路和上面第二高的薪水是一样的</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> getNthHighestSalary(N <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">declare</span> m <span class="hljs-type">int</span>;<br>    <span class="hljs-keyword">set</span> m <span class="hljs-operator">=</span> N<span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">RETURN</span> (<br>      # Write your MySQL query statement below.<br>      <span class="hljs-keyword">select</span> ifnull(<br>          (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> Salary<br>          <span class="hljs-keyword">from</span> Employee<br>          <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Salary <span class="hljs-keyword">desc</span><br>          limit <span class="hljs-number">1</span> <span class="hljs-keyword">offset</span> m),<span class="hljs-keyword">null</span><br>      )<br>  );<br><span class="hljs-keyword">END</span><br></code></pre></div></td></tr></table></figure><div class="note note-warning">            <p>其实没有什么不一样的，但是第三行和第四行是需要注意一下的。</p><p><strong>问题1</strong>：为什么是跳过N-1</p><p>这个很简单，没有什么好说的，第二高的薪水你不是跳过1条记录吗</p><p><strong>问题2</strong>：为什么不能在offset后面直接加N-1</p><p><font color='red'>因为语法要求在offset后面不可以有运算。同样的，limit后面也不允许</font></p><p>关于第四行，直接对N–也是可行的</p>          </div><p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202110092352564.png" alt="力扣刷题"></p><hr><p>关于ifnull</p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第二高的薪水&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#第二高的薪水&quot;&gt;¶&lt;/a&gt;第二高的薪水&lt;/h3&gt;
&lt;h4 id=&quot;题目地址&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目地址&quot;&gt;¶&lt;/a&gt;题目地址&lt;/h4&gt;
</summary>
      
    
    
    
    <category term="Database" scheme="https://conquerorlei.github.io/categories/Database/"/>
    
    <category term="MySQL" scheme="https://conquerorlei.github.io/categories/Database/MySQL/"/>
    
    
    <category term="SQL" scheme="https://conquerorlei.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>换酒问题</title>
    <link href="https://conquerorlei.github.io/posts/3b3e846/"/>
    <id>https://conquerorlei.github.io/posts/3b3e846/</id>
    <published>2021-10-09T13:50:11.000Z</published>
    <updated>2021-10-12T01:03:48.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a class="header-anchor" href="#题目地址">¶</a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/water-bottles/">1518. 换酒问题 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h3 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h3><p>基本思路不是很简单？</p><p>既然可以换酒瓶，我喝够了能换的酒瓶数就拿着空酒瓶就去换啊，能换一个是一个(<font color='red'>模拟算法</font>)</p><p>但是有的时候我喝够了可以换的酒瓶数，但是我贪心我懒我不想去换或者说我对自己的生活有规划(<font color='cornflowerblue'>后面这句才符合我</font>)，那我就先攒着，直到剩下的不能再换了再去换，喝完了再攒着，直到我没法换了为止(<font color='red'>贪心递归</font>)</p><h3 id="代码展示"><a class="header-anchor" href="#代码展示">¶</a>代码展示</h3><p>好了，不贫了，直接上才艺</p><p><img src="https://tse1-mm.cn.bing.net/th/id/R-C.e35e7bd5dbfe5abc91f025fb7147a43c?rik=B4PiIjvT%2bflRGg&amp;riu=http%3a%2f%2f5b0988e595225.cdn.sohucs.com%2fimages%2f20180907%2f635c9726470449c1a65c688516a3c4b7.gif&amp;ehk=7yMeyB3x3m43kx%2bGBAzD%2fw9YL52yoiDclnkQ6M95msU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="上才艺"></p><p><strong>模拟</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWaterBottles</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numBottles, <span class="hljs-keyword">int</span> numExchange)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numBottles &lt; numExchange)<span class="hljs-keyword">return</span> numBottles;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(numBottles &gt;= numExchange)&#123;<br>            sum += numExchange;<br>            numBottles -= numExchange;<br>            numBottles++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numBottles + sum;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>递归</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWaterBottles</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numBottles, <span class="hljs-keyword">int</span> numExchange)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numBottles &lt; numExchange)<span class="hljs-keyword">return</span> numBottles;<br>        <span class="hljs-keyword">return</span> numBottles - numBottles%numExchange + numWaterBottles(numBottles/numExchange + numBottles%numExchange,numExchange);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>贪心算法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWaterBottles</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numBottles, <span class="hljs-keyword">int</span> numExchange)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numBottles &lt; numExchange)<span class="hljs-keyword">return</span> numBottles;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(numBottles &gt;= numExchange)&#123;<br>            sum += numBottles - numBottles%numExchange;<br>            numBottles = numBottles/numExchange + numBottles%numExchange;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum + numBottles;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><div class="note note-success">            <p>有没有感觉其实贪心算法其实只是展开了递归，减少了递归的栈容量消耗。</p><p>其实内存相差无几。</p>          </div><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目地址&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目地址&quot;&gt;¶&lt;/a&gt;题目地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/water-bottles/&quot;&gt;1518. 换酒问题 -</summary>
      
    
    
    
    <category term="Programming Language" scheme="https://conquerorlei.github.io/categories/Programming-Language/"/>
    
    <category term="Java" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/"/>
    
    <category term="Apply" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/Apply/"/>
    
    <category term="Algorithm" scheme="https://conquerorlei.github.io/categories/Algorithm/"/>
    
    <category term="递归" scheme="https://conquerorlei.github.io/categories/Algorithm/%E9%80%92%E5%BD%92/"/>
    
    <category term="贪心算法" scheme="https://conquerorlei.github.io/categories/Algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="模拟法" scheme="https://conquerorlei.github.io/categories/Algorithm/%E6%A8%A1%E6%8B%9F%E6%B3%95/"/>
    
    
    <category term="Daily" scheme="https://conquerorlei.github.io/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>MySQL insert into和select into</title>
    <link href="https://conquerorlei.github.io/posts/8e41bd02/"/>
    <id>https://conquerorlei.github.io/posts/8e41bd02/</id>
    <published>2021-10-09T08:27:52.000Z</published>
    <updated>2021-10-09T14:55:47.710Z</updated>
    
    <content type="html"><![CDATA[<p>绝了，学了这么久还是只会<code>insert into</code>，像是个废人</p><p>ok，废话不多说，淦！</p><span id="more"></span><p>今天在牛客上刷了一道题：<font color='red'>某打车公司要将驾驶里程（drivedistanced）超过5000里的司机信息转存到一张称为seniordrivers 的表中，他们的详细情况被记录在表drivers 中</font></p><p>我惊醒，这不就是insert into嘛，小菜一碟，后来想起来真的是，我是fw</p><h3 id="insert-into"><a class="header-anchor" href="#insert-into">¶</a>insert into</h3><p>isnert into 常用于<strong>向表中插入新行</strong></p><div class="note note-primary">            <figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,....)<br><span class="hljs-comment">-- 指定所要插入数据的列：</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (列<span class="hljs-number">1</span>, 列<span class="hljs-number">2</span>,...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,....)<br></code></pre></div></td></tr></table></figure>          </div><h3 id="select-into"><a class="header-anchor" href="#select-into">¶</a>select into</h3><p>SELECT INTO 语句<strong>从一个表中选取数据，然后把数据插入另一个表中</strong>。常用于创建表的备份复件或者用于对记录进行存档。</p><div class="note note-primary">            <figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-comment">-- 把所有的列插入新表 </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">INTO</span> new_table_name [<span class="hljs-keyword">IN</span> externaldatabase] <br><span class="hljs-keyword">FROM</span> old_tablename<br></code></pre></div></td></tr></table></figure>          </div><h3 id="题目答案"><a class="header-anchor" href="#题目答案">¶</a>题目答案</h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">into</span> seniordrivers<br><span class="hljs-keyword">where</span> drivedistanced <span class="hljs-operator">&gt;</span> <span class="hljs-number">5000</span><br><span class="hljs-keyword">from</span> drivers;<br></code></pre></div></td></tr></table></figure><p>这是什么数据库的写法，Get</p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;绝了，学了这么久还是只会&lt;code&gt;insert into&lt;/code&gt;，像是个废人&lt;/p&gt;
&lt;p&gt;ok，废话不多说，淦！&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://conquerorlei.github.io/categories/Database/"/>
    
    <category term="MySQL" scheme="https://conquerorlei.github.io/categories/Database/MySQL/"/>
    
    
    <category term="SQL" scheme="https://conquerorlei.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 事务管理</title>
    <link href="https://conquerorlei.github.io/posts/769c2380/"/>
    <id>https://conquerorlei.github.io/posts/769c2380/</id>
    <published>2021-10-07T00:48:03.000Z</published>
    <updated>2021-10-09T14:55:47.709Z</updated>
    
    <content type="html"><![CDATA[<p>事务就是一组DML语句组成，这些语句在逻辑上存在相关性，要么全部成功执行，要么全部失败执行，是一个整体。</p><p>MySQL提供一种机制，保证我们达到这样的效果。</p><p>事务还规定，不同的客户端看到的数据是不一样的。</p><h3 id="事务基本操作"><a class="header-anchor" href="#事务基本操作">¶</a>事务基本操作</h3><h4 id="测试表"><a class="header-anchor" href="#测试表">¶</a>测试表</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> account(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> balance <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0.0</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.07</span> sec)<br></code></pre></div></td></tr></table></figure><h4 id="开始一个事务"><a class="header-anchor" href="#开始一个事务">¶</a>开始一个事务</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction;<br></code></pre></div></td></tr></table></figure><h4 id="创建一个保存点"><a class="header-anchor" href="#创建一个保存点">¶</a>创建一个保存点</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">savepoint</span> point_name;<br></code></pre></div></td></tr></table></figure><h4 id="回到保存点"><a class="header-anchor" href="#回到保存点">¶</a>回到保存点</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> point_name;<br></code></pre></div></td></tr></table></figure><h4 id="代码演示"><a class="header-anchor" href="#代码演示">¶</a>代码演示</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> transaction;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">savepoint</span> aa;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">10</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">savepoint</span> bb;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">10000</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+----------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span> balance  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+----------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> 张三 <span class="hljs-operator">|</span>    <span class="hljs-number">10.00</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> 李四 <span class="hljs-operator">|</span> <span class="hljs-number">10000.00</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+----------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br><br><span class="hljs-comment">-- 发现第二次插入是误操作，回滚到bb状态</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> bb;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+---------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+---------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> 张三 <span class="hljs-operator">|</span>   <span class="hljs-number">10.00</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+---------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></div></td></tr></table></figure><h3 id="事务操作注意事项"><a class="header-anchor" href="#事务操作注意事项">¶</a>事务操作注意事项</h3><ul><li>没有设置保存点，也可以进行回滚，只能回滚到事务的开始，<font color='red'>直接使用roolback</font></li><li>如果一个事务被提交(commit)了，则不可以回滚</li><li>可以选择回退到那个保存点</li><li>InnoDB支持事务，MyISAM不支持事务</li><li>开始事务使用<code>start transaction</code></li></ul><h3 id="事务的隔离级别"><a class="header-anchor" href="#事务的隔离级别">¶</a>事务的隔离级别</h3><p>当我们有多个客户端同时操作数据库的某张表的时候，如何就行隔离操作？MySQL提供了机制。</p><p>当MySQL表被多个线程或者客户端开启各自事务操作数据库中的数据时，MySQL提供了一种机制，可以让不同的事务在操作数据师，具有隔离性，从而保证数据的一致性。</p><h4 id="无隔离性的问题"><a class="header-anchor" href="#无隔离性的问题">¶</a>无隔离性的问题</h4><h5 id="脏读"><a class="header-anchor" href="#脏读">¶</a>脏读</h5><p>是指一个事务对数据库中的数据进行了修改，但是这种修改并没有被提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据；</p><h5 id="不可重复读"><a class="header-anchor" href="#不可重复读">¶</a>不可重复读</h5><p>是指在一个事务中，多次重复读同一个数据。这样在事务对同一个事务的两次读之间，第二个事务可能对数据进行修改，这样的话就可能出现两次读取数据不一样的情况。也就是说发生了在一个事务内两次读到的数据是不一样的，也能为此称为不可重复读</p><p><strong>解决方法</strong>：另外一个事务完全提交之后，才可以读取数据，则可以避免该问题</p><h5 id="幻读"><a class="header-anchor" href="#幻读">¶</a>幻读</h5><p>事务不是独立执行时的一种现象。</p><p><strong>案例</strong>：一个事务对表中的数据进行了修改，涉及到了数据表的全部行。此时第二个事务向表中插入了一行数据，这样像是第一个事务没有修改全部的数据行一样，就像是发生了幻觉。</p><p><strong>解决方案</strong>：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可以避免这种问题</p><div class="note note-warning">            <p>不可重复读的重点是修改：同样的条件，读取的数据再次读取发现值不一样了。</p><p>幻读的重点在于新增或者删除：同样的条件，第一次和第二次读出来的记录数不一样。</p>          </div><h4 id="隔离级别"><a class="header-anchor" href="#隔离级别">¶</a>隔离级别</h4><table><thead><tr><th>隔离界别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>读未提交(read uncommitted)</td><td>✅</td><td>✅</td><td>✅</td><td>不加锁</td></tr><tr><td>读已提交(read committed)</td><td>❎</td><td>✅</td><td>✅</td><td>不加锁​</td></tr><tr><td>可重复读(repeatable read)</td><td>❎</td><td>❎</td><td>❎</td><td>不加锁​</td></tr><tr><td>可串行化(serializable)</td><td>❎</td><td>❎</td><td>❎</td><td>加锁​</td></tr></tbody></table><p>说明：</p><p>❎表示不会发生</p><p>✅表示会发生</p><h5 id="设置隔离级别"><a class="header-anchor" href="#设置隔离级别">¶</a>设置隔离级别</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session transaction isolation level read uncommitted;<br></code></pre></div></td></tr></table></figure><h5 id="查看隔离级别"><a class="header-anchor" href="#查看隔离级别">¶</a>查看隔离级别</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation;<br></code></pre></div></td></tr></table></figure><h3 id="事务的ACID特性"><a class="header-anchor" href="#事务的ACID特性">¶</a>事务的ACID特性</h3><h4 id="原子性-Atomicity"><a class="header-anchor" href="#原子性-Atomicity">¶</a>原子性(Atomicity)</h4><p>事务是应用中最小的执行单位，具有不可再分的特征。事务是应用中不可再分的最小逻辑执行体</p><h4 id="一致性-Consistency"><a class="header-anchor" href="#一致性-Consistency">¶</a>一致性(Consistency)</h4><p>事务执行的结果，必须从一个一致性状态变成另外一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。如果系统运行发生中断，某个事物尚未完成而被迫中断，而该未完成的事务对数据库的修改已经写入数据库，此时数据库就处于一种不确定不一致的状态。因此一致性是通过原子性来保证的。</p><h4 id="隔离性-Isolation"><a class="header-anchor" href="#隔离性-Isolation">¶</a>隔离性(Isolation)</h4><p>各个事务的执行互不干扰，任意一个事物的内部操作对其他并发事物都是隔离的。也就是说，并发执行的事物之间不能看到对方的状态，并发执行的事务之间不能相互影响。</p><h4 id="持久性-Durability"><a class="header-anchor" href="#持久性-Durability">¶</a>持久性(Durability)</h4><p>持久性是指一个事务一旦被提交，它对数据库的修改要记录到永久存储器中。</p><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;事务就是一组DML语句组成，这些语句在逻辑上存在相关性，要么全部成功执行，要么全部失败执行，是一个整体。&lt;/p&gt;
&lt;p&gt;MySQL提供一种机制，保证我们达到这样的效果。&lt;/p&gt;
&lt;p&gt;事务还规定，不同的客户端看到的数据是不一样的。&lt;/p&gt;
&lt;h3 id=&quot;事务基本操作&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Database" scheme="https://conquerorlei.github.io/categories/Database/"/>
    
    <category term="MySQL" scheme="https://conquerorlei.github.io/categories/Database/MySQL/"/>
    
    
    <category term="SQL" scheme="https://conquerorlei.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse常用快捷键</title>
    <link href="https://conquerorlei.github.io/posts/4281c41c/"/>
    <id>https://conquerorlei.github.io/posts/4281c41c/</id>
    <published>2021-09-29T12:24:03.000Z</published>
    <updated>2021-10-09T14:55:47.699Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/QingShanxl/pictures/raw/master/img/202109292029586.png" alt="Eclipse"></p><span id="more"></span><p>Eclipse中的快捷键</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl+/</td><td>代码补全</td></tr><tr><td>Ctrl+1</td><td>代码修复</td></tr><tr><td>Ctrl+Shift+O</td><td>批量导包</td></tr><tr><td>Ctrl+/</td><td>单行注释</td></tr><tr><td>Ctrl+Shift+/</td><td>多行注释</td></tr><tr><td>Ctrl+Shift+\</td><td>取消多行注释</td></tr><tr><td>Alt+UP</td><td>代码上移</td></tr><tr><td>Alt+Down</td><td>代码下移</td></tr><tr><td>Shift+Enter</td><td>切换到上一行代码空位</td></tr><tr><td>Ctrl+Shift+Enter</td><td>切换到上一行代码空位</td></tr><tr><td>Ctrl+点击选中部分，Ctrl+Shift+t</td><td>查看源码，搜索指定的结构</td></tr><tr><td>Alt+Left</td><td>进入到上一个页面</td></tr><tr><td>Alt+Right</td><td>进入到下一个页面</td></tr><tr><td>Ctrl+t</td><td>查看继承树结构</td></tr><tr><td>Ctrl+Shift+f</td><td>格式化代码</td></tr><tr><td>Ctrl+O</td><td>显示当前类结构，并支持搜索指定的方法和属性</td></tr><tr><td>ALt+Shift+R</td><td>批量修改指定的变量名、方法名、类名</td></tr><tr><td>Ctrl+Shift+x</td><td>选中的结构大小写的切换：变成大写</td></tr><tr><td>Ctrl+Shift+y</td><td>选中的结构大小写的切换：变成小写</td></tr><tr><td>Alt+Shift+s</td><td>调出getter和setter构造器</td></tr><tr><td>Alt+enter</td><td>调出当前工程或者文件夹得属性</td></tr><tr><td>Ctrl+f</td><td>查询替换</td></tr><tr><td>Ctrl+k</td><td>快速查找</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/QingShanxl/pictures/raw/master/img/202109292029586.png&quot; alt=&quot;Eclipse&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Software" scheme="https://conquerorlei.github.io/categories/Software/"/>
    
    <category term="Eclipse" scheme="https://conquerorlei.github.io/categories/Software/Eclipse/"/>
    
    
    <category term="Sundry" scheme="https://conquerorlei.github.io/tags/Sundry/"/>
    
    <category term="Daily" scheme="https://conquerorlei.github.io/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>Java 关键字的使用</title>
    <link href="https://conquerorlei.github.io/posts/6152a1b5/"/>
    <id>https://conquerorlei.github.io/posts/6152a1b5/</id>
    <published>2021-09-24T13:50:35.000Z</published>
    <updated>2021-10-09T14:55:47.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="this关键字的使用"><a class="header-anchor" href="#this关键字的使用">¶</a>this关键字的使用</h3><ol><li><p><font color='cornflowerblue'>this</font>可以用来修饰：属性、方法、构造器</p></li><li><p><font color='cornflowerblue'>this</font>修饰属性和方法：<font color='cornflowerblue'>this</font>表示的是当前的对象</p><ol><li>可以使用&quot;<font color='orange'>this.属性</font>“、”<font color='orange'>this.方法</font>&quot;的方式调用当前对象或者当前正在创建属性的方法。但是通常情况下，我们都选择省略<font color='cornflowerblue'>this</font>.，特殊情况也就是重名问题时，必须显式使用</li><li>可以在构造器中使用<font color='cornflowerblue'>this</font>，也是重名问题</li></ol></li><li><p><font color='cornflowerblue'>this</font>调用构造器</p><ol><li><p>在类的构造器中，可以显式地使用&quot;<font color='orange'>this(形参列表)</font>&quot;的方式，调用本类的指定的其它构造器</p></li><li><p><font color='red'>不能调用自己</font></p></li><li><p>如果一个类中有n个构造器，则最多有n - 1个使用了&quot;<font color='orange'>this(形参列表)</font>&quot;的方式调用构造器</p><p>防止闭环情况的发生，也就是自己调用自己</p></li><li><p>构造器的调用必须声明在当前构造器的首行</p></li><li><p>构造内部，最多只能声明一个&quot;<font color='orange'>this(形参列表)</font>&quot;，用来调用其他的构造器</p></li></ol></li></ol><p><font color='cornflowerblue'>this</font>指针的使用是为了解决重名问题，为什么要解决这个问题，首先考虑以下代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.conquerorlei.java;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-keyword">private</span> String name;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,String name)</span> </span>&#123;<br>id = id;<br>name = name;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么在构造一个对象的过程中，调用有参构造器的时候，我就分不清那个id是哪个id，那我为什么不可以使用首字母呢，答案是可以的。但是一个资深程序员不会这样写，为什么？因为直接使用全称有利于理解代码。这样的话，<font color='cornflowerblue'>this</font>关键字的使用就很重要了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.conquerorlei.java;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-keyword">private</span> String name;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><div class="note note-primary">            <blockquote><p>上述部分描述引自《Java核心技术：卷一》</p></blockquote>          </div><h3 id="package关键字的使用"><a class="header-anchor" href="#package关键字的使用">¶</a>package关键字的使用</h3><ol><li>为了更好的实现项目中类的管理，提供包的概念</li><li>使用<font color='orange'>package</font>font&gt;声明类或者接口所属的包，声明在源文件的首行</li><li>包，属于标识符，遵循标识符的命名规则</li><li>每一个<font color='cornflowerblue'>“.”</font>，表示一层文件目录</li></ol><div class="note note-warning">            <p>同一个包下，不能命名同名的接口、类</p><p>不同的包下，可以命名同行的接口、类</p>          </div><h4 id="JDK常见的包名"><a class="header-anchor" href="#JDK常见的包名">¶</a>JDK常见的包名</h4><table><thead><tr><th>包名</th><th>介绍</th></tr></thead><tbody><tr><td>java.lang</td><td>包含一些Java语言的核心类， 如String、 Math、 <br/>Integer、 System和Thread， 提供常用功能</td></tr><tr><td><a href="http://java.net">java.net</a></td><td>包含执行与网络相关的操作的类和接口。</td></tr><tr><td><a href="http://java.io">java.io</a></td><td>包含能提供多种输入/输出功能的类。</td></tr><tr><td>java.util</td><td>包含一些实用工具类， 如定义系统特性、<br/> 接口的集合框架类、 使用与日期日历相关的函数。</td></tr><tr><td>java.text</td><td>包含了一些java格式化相关的类</td></tr><tr><td>java.sql</td><td>包含了java进行JDBC数据库编程的相关类/接口</td></tr><tr><td>java.awt</td><td>包含了构成抽象窗口工具集（abstract window toolkits）<br/> 的多个类， 这些类被用来构建和管理应用程序的图形用<br/>户界面(GUI)。 B/S C/S</td></tr></tbody></table><h4 id="MVC设计模式"><a class="header-anchor" href="#MVC设计模式">¶</a>MVC设计模式</h4><p>MVC是常用的设计模式，将整个程序分为三个层次：视图模型层，控制器层，数据模型层</p><h5 id="模型层-font-color-red-model-font-主要处理数据"><a class="header-anchor" href="#模型层-font-color-red-model-font-主要处理数据">¶</a>模型层 <font color='red'>model</font>主要处理数据</h5><p>数据对象封装 <font color='orange'>model.bean/demain</font></p><p>数据库操作类 <font color='orange'>model.dao</font></p><p>数据库 <font color='orange'>model.dao</font></p><h5 id="控制层-font-color-red-controller-font-处理业务逻辑"><a class="header-anchor" href="#控制层-font-color-red-controller-font-处理业务逻辑">¶</a>控制层 <font color='red'>controller</font>处理业务逻辑</h5><p>应用界面相关<font color='orange'> controller.activity</font></p><p>存放fragment <font color='orange'>controller.fragment</font></p><p>显示列表的适配器 <font color='orange'>controller.adapter</font></p><p>服务相关的 <font color='orange'>controller.service</font></p><p>抽取的基类 <font color='orange'>controller.base</font></p><h5 id="视图层-font-color-red-view-font-显示数据"><a class="header-anchor" href="#视图层-font-color-red-view-font-显示数据">¶</a>视图层 <font color='red'>view</font>显示数据</h5><p>相关工具类 <font color='orange'>view.utils</font></p><p>自定义<font color='red'>view</font> <font color='orange'>view.ui</font></p><h3 id="import关键字的使用"><a class="header-anchor" href="#import关键字的使用">¶</a>import关键字的使用</h3><ol><li>在源文件中现实的使用<font color='orange'>import</font>结构导入指定包下的类、接口</li><li>声明在包的声明和类的声明之间</li><li>如果需要导入多个结构，则并列写出即可</li><li>可以使用<font color='red'>“xxx.*”</font>的方式，表示可以导入xxx包下的所有结构</li><li>如果使用的类或者接口是<font color='red'>java.lang</font>包下定义的，可以直接省略<font color='orange'>import</font></li><li>如果是用的类或者接口是本包下定义的，可以省略<font color='orange'>import</font></li><li>如果在源文件中，使用了不同包下的同名的类，则至少有一个类需要使用全类名的方式显示</li><li>如果要调用<font color='red'>xxx</font>子包下的类，那么仍需要显示，不能使用<font color='red'>“* . *”</font></li><li><font color='orange'>import static</font> ：表示的导入指定类或者接口中的静态结构：静态域或者静态方法</li></ol><blockquote class="blockquote-center">人的一切痛苦，本质上是对自己的无能的愤怒<br>王小波</blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;this关键字的使用&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#this关键字的使用&quot;&gt;¶&lt;/a&gt;this关键字的使用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#39;cornflowerblue&#39;&gt;this&lt;/font&gt;可以</summary>
      
    
    
    
    <category term="Programming Language" scheme="https://conquerorlei.github.io/categories/Programming-Language/"/>
    
    <category term="Java" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/"/>
    
    <category term="Base" scheme="https://conquerorlei.github.io/categories/Programming-Language/Java/Base/"/>
    
    
    <category term="Sundry" scheme="https://conquerorlei.github.io/tags/Sundry/"/>
    
    <category term="OOP" scheme="https://conquerorlei.github.io/tags/OOP/"/>
    
    <category term="Keywords" scheme="https://conquerorlei.github.io/tags/Keywords/"/>
    
  </entry>
  
</feed>
